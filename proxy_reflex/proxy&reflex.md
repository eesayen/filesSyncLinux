##  代理和反射-proxy&reflex



### 代理-proxy

- Proxy是es6新增的一个构造函数 - 可以理解为js语言的一个代理， 用来改变js默认的一些语言行为

- Proxy对象用于创建一个对象的代理， 从而实现原本对对象基本操作的拦截和自定义， 如属性的查找，赋值，枚举，函数的调用等

- Proxy对象用于 **定义基本操作的自定义行为**，等同于语言层面做出修改，属于一种元编程，即 对编程语言进行编程

  ---

  ##### 语法

  ```js
  const p=new Proxy(target, handler)
  //target 
  //要使用proxy包装的对象，(可以是任何类型的对象, 包括原生数组,函数,甚至另一个代理)
  //handler
  //一个配置对象,通常以函数作为属性, 各属性中的函数分别定义了在执行各种操作时代理p的行为
  
  ```

- 构造函数Proxy中静态方法（原型对象上的方法）revocable（）创建一个可撤销的Proxy对象

  - 参数和构造函数完全相同
  - 它返回一个的对象，包含了1.所生成的代理对象本身 2.该代理对象的撤销方法

  ```js
  Proxy.revocable()
  ```

  ---

  ##### handler对象的方法

- handle对象容纳一批特定属性的占位符对象，它包含proxy的各个捕捉器（trap）
  - 所有的捕捉器都是可选的，如果没有定义某个捕捉器，那么保留源对象的默认行为
- handler.getPrototypeOf( )
  - Object.getPrototypeOf方法捕捉器
- handler.get( )
  - 属性读取操作的捕捉器
- handler.has( )
  - in操作符的捕捉器



---

- 在拦截默认行为后的自定义操作中，实际上还是需要根据需求手动对被代理的对象进行操作，返回的代理对象只起行为拦截的作用
- 代理的是函数， 调用返回的代理，传入handler的apply捕捉器才会生效，代理的是对象， 对象中的某个属性是函数， 通过返回的代理对象调用函数， apply捕捉器不会生效 









---



## reflex

- `Reflect`是一个内置的对象，它提供拦截 JavaScript 操作的方法。Reflect不是一个函数对象，因此它是不可构造的。`Reflect`的所有的方法都是静态的就和`Math`一样，目前它还没有静态属性。

- `Reflect`对象的方法与`Proxy`对象的方法相同。

- `Reflect` 目前一共有13个静态方法：
  - 它可以分为一部分是是原来存在`Object`上的方法，将它转义到了`Reflect`上，并作了小改动，让方法更加合理。
  - 另一部分是将原来操作符的功能，变成函数行为。


